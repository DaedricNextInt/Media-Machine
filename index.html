<!DOCTYPE html>
<html>
<head>
    <title>iPod Music Player with Folder Grid</title>
    <style>
        body { margin: 0; 
            overflow: hidden;
            background-color: transparent !important; 
            /* -webkit-app-region: drag; */
        
        }
        canvas { display: block; }
        #view-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: transparent !important; 
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            z-index: 10;
            -webkit-app-region: drag;
        }
        #folder-input {
            display: none;
        }
        #audio-player {
        position: absolute;
        bottom: 10px;
        left: 150px;
        width: 80%;
        z-index: 10;
        opacity: 0.5;
        /* Custom colors */
        /* background-color: #ff5500; /* Orange */
        border-radius: 10px; /* Rounded corners */
        /* padding: 5px; */
        }
    </style>
</head>
<body>
    <div id="view-indicator">Current View: Default</div>
    <input type="file" id="folder-input" webkitdirectory directory multiple />
    <audio id="audio-player" controls>
        
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
		import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- Basic Setup ---
        const scene = new THREE.Scene();
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ 
            
           alpha:true
        
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        renderer.setClearColor(0x000000, 0); // Set clear color to transparent black

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // /*ROOM FOR REFLECTIONS*/
        // const environment = new RoomEnvironment();
        // const pmremGenerator = new THREE.PMREMGenerator(renderer);
        // scene.environment = pmremGenerator.fromScene(environment).texture;


        
        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;

        // --- IPOD MODEL CODE ---
        
        const ipodWidth = 15.5;
        const ipodHeight = 8;
        const ipodDepth = 1;
        const screenWidth = 8;
        const screenHeight = 6;
        const wheelOuterRadius = .5;
        const wheelInnerRadius = 0.8;
        const buttonRadius = wheelInnerRadius * 0.8;
        //let isMusicPage = false;

        const ipodGroup = new THREE.Group();
        scene.add(ipodGroup);

        // 1. iPod Body
        const bodyGeometry = new THREE.BoxGeometry(ipodWidth, ipodHeight, ipodDepth);
        const frontMaterial = new THREE.MeshStandardMaterial({
             color: 0xffffff, roughness: 0, metalness: 0.9 });
        const backMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.6 });
        const edgeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6, metalness: 0.9 });
        const bodyMaterials = [edgeMaterial, edgeMaterial, edgeMaterial, edgeMaterial, frontMaterial, backMaterial];
        const ipodBody = new THREE.Mesh(bodyGeometry, bodyMaterials);
        ipodGroup.add(ipodBody);

        // 2. Screen
        const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
        const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,       // Base color (black)
        emissive: 0xF1C232,    // Orange glow color
        emissiveIntensity: 1.0, // Adjust intensity (0-2) 
        roughness: 0,
        metalness: 1
        });
       
        const screenMesh = new THREE.Mesh(screenGeometry, screenMaterial);
        screenMesh.position.x = 3;
        screenMesh.position.z = ipodDepth / 2 + 0.01;
        screenMesh.position.y = (ipodHeight / 2) - 4 ;
        ipodGroup.add(screenMesh);

        // 3. Image Preview Screen
        const imageScreen = new THREE.PlaneGeometry(6, screenHeight);
        const imageScreenMaterial = new THREE.MeshStandardMaterial
        ({
        color: 0x000000,       // Base color (black)
        emissive: 0xF1C232,    // Orange glow color
        roughness: 0.1,
        // map: texture,
        emissiveIntensity: 1.0 // Adjust intensity (0-2)   
        })
        const imageScreenMesh = new THREE.Mesh(imageScreen, imageScreenMaterial);
        imageScreenMesh.position.x = -4.3;
        imageScreenMesh.position.z = ipodDepth / 2 + 0.01;
        imageScreenMesh.position.y = (ipodHeight / 2) - 4; 
        ipodGroup.add(imageScreenMesh);


        
        
        /*GLOWING EFFECT*/
        const screenGlowLight = new THREE.PointLight(0xff5500, 1, 10); // Orange glow
        screenGlowLight.position.copy(screenMesh.position);
        screenGlowLight.position.z += 0.2; // Slightly in front of the screen
        ipodGroup.add(screenGlowLight);

        // // 3. Click Wheel
        // const clickWheelGroup = new THREE.Group();
        // clickWheelGroup.position.y = -(ipodHeight / 2) * 0.35;
        // clickWheelGroup.position.z = ipodDepth / 2 + 0.01;
        // ipodGroup.add(clickWheelGroup);

        // // a) Outer Ring
        // const wheelRingGeometry = new THREE.RingGeometry(wheelInnerRadius, wheelOuterRadius, 32);
        // const wheelRingMaterial = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.7, side: THREE.DoubleSide });
        // const wheelRingMesh = new THREE.Mesh(wheelRingGeometry, wheelRingMaterial);
        // clickWheelGroup.add(wheelRingMesh);

        // // b) Center Button
        // const centerButtonGeometry = new THREE.CircleGeometry(buttonRadius, 32);
        // const centerButtonMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.7 });
        // const centerButtonMesh = new THREE.Mesh(centerButtonGeometry, centerButtonMaterial);
        // clickWheelGroup.add(centerButtonMesh);

        // --- Menu & Music System ---
        let selectedMenuItem = 0;
        const menuItems = ["Music", "Photos", "Videos", "Podcasts", "Extras", "Settings", "Shuffle Songs"];
        const menuGroup = new THREE.Group();
        menuGroup.position.x = 3;
        menuGroup.position.z = ipodDepth / 2 + 0.02;
        menuGroup.position.y = screenMesh.position.y;
        menuGroup.visible = true;
        ipodGroup.add(menuGroup);

        /*MENU TITLE*/
        const titleGroup = new THREE.Group();
        titleGroup.position.x = 3;
        titleGroup.position.z = ipodDepth / 2 + 0.02;
        titleGroup.position.y = screenMesh.position.y;
        titleGroup.visible = true;
        ipodGroup.add(titleGroup);


        // Music library state
        let allMusicLibrary = {};
        let currentMusicLibrary = [];
        let selectedMusicItem = 0;
        let musicPageScrollOffset = 0;
        const ITEMS_PER_SCREEN = 10;

        let currentPage = 'mainMenu';
        let loadedFont = null;

        const musicPageGroup = new THREE.Group();
        musicPageGroup.position.x = 3;
        musicPageGroup.position.z = ipodDepth / 2 + 0.02;
        musicPageGroup.position.y = screenMesh.position.y;
        musicPageGroup.visible = false;
        ipodGroup.add(musicPageGroup);

        // --- Music Directory Sidebar ---
        const sidebarGroup = new THREE.Group();
        sidebarGroup.position.z = ipodDepth / 2 + 0.03;
        sidebarGroup.position.x = screenWidth / 2 + 5 ;
        sidebarGroup.position.y = screenMesh.position.y;
        sidebarGroup.visible = true;
        ipodGroup.add(sidebarGroup);

        let musicDirectories = [];
        let selectedDirectoryIndex = -1;

        // Store meshes for raycasting
        const clickableMeshes = {
            mainMenu: [],
            musicPage: [],
            sidebar: []
        };

        // Audio Player Element
        const audioElement = document.getElementById('audio-player');
        let currentObjectUrl = null;


        /*Image Library inits*/
        let allImageLibrary = {};
        let currentImageLibrary = [];
        let selectedImageItem = 0;
        let currentImageTexture = null;
        let currentImageMesh = null;


 // --- Audio Visualizer Setup ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const source = audioContext.createMediaElementSource(audioElement);
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        
                
        
        
        // --- Audio Event Listeners ---
        if (audioElement && audioContext) {
            audioElement.addEventListener('play', () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            });

            audioElement.addEventListener('pause', () => {
                console.log('Audio paused');
            });

            audioElement.addEventListener('ended', () => {
                if (currentPage === 'musicPage' && currentMusicLibrary && currentMusicLibrary.length > 0) {
                    const nextIndex = (selectedMusicItem + 1) % currentMusicLibrary.length;
                    selectedMusicItem = nextIndex;
                    
                    const selectedDisplayIndex = selectedMusicItem - musicPageScrollOffset;
                    if (selectedDisplayIndex < 0) {
                        musicPageScrollOffset = selectedMusicItem;
                    } else if (selectedDisplayIndex >= ITEMS_PER_SCREEN) {
                        musicPageScrollOffset = selectedMusicItem - ITEMS_PER_SCREEN + 1;
                    }
                    
                    musicPageScrollOffset = Math.max(0, Math.min(musicPageScrollOffset, currentMusicLibrary.length - ITEMS_PER_SCREEN));
                    if (currentMusicLibrary.length <= ITEMS_PER_SCREEN) musicPageScrollOffset = 0;
                    
                    selectMusicItem(nextIndex);
                    
                    if (loadedFont) {
                        createMusicPageElements();
                    }
                }
            });
        } else {
            console.error('Audio element or context is not initialized.');
        }



        // --- Font Loading ---
        const fontLoader = new FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            loadedFont = font;
            createMenuItems();
            createMusicPageElements();
            createSidebarElements();
        });


        // --- Create Sidebar Elements ---
        function createSidebarElements() {
            if (!loadedFont) return;

            const sidebarWidth = 2.5;
            const sidebarHeight = screenHeight * 0.9;
            const textSize = 0.2;

            /* GRID LAYOUT */
            const padding = 0.5;
            const itemHeight = 0.8;
            const itemWidth = 1.2;
            const spacingX = 0.3;
            const spacingY = 0.3;
            const columns = 3;

            const startX = -sidebarWidth / 2 + padding + itemWidth / 2;
            const startY = screenHeight / 2 - padding - itemHeight / 2;

            // Clear previous directory items
            const childrenToRemove = [];
            sidebarGroup.children.forEach(child => {
                if (child.userData?.type?.startsWith('directory') || child.userData?.type === 'directoryItem') {
                    childrenToRemove.push(child);
                }
            });
            childrenToRemove.forEach(child => {
                sidebarGroup.remove(child);
                if (clickableMeshes.sidebar.includes(child)) {
                    clickableMeshes.sidebar.splice(clickableMeshes.sidebar.indexOf(child), 1);
                }
            });

            // Add button at the top
            const addButtonY = screenHeight / 2 - padding - itemHeight * 0.6; // Position at the top
            const addButtonX = -sidebarWidth / 2 + padding + itemWidth / 2; // Centered at the top

            const addButtonGeometry = new RoundedBoxGeometry(sidebarWidth - 2 * padding, itemHeight * 0.6, 0.01, 0.1);
            const addButtonMaterial = new THREE.MeshBasicMaterial({
                color: 0x333333,
                opacity: 0.1,
                transparent: true
            });
            const addButtonMesh = new THREE.Mesh(addButtonGeometry, addButtonMaterial);
            addButtonMesh.position.set(0, addButtonY, 0.01); // Center the add button
            addButtonMesh.userData = { type: 'addButtonBg' };
            sidebarGroup.add(addButtonMesh);

            const addTextGeometry = new TextGeometry("+ Add Folder", {
                font: loadedFont,
                size: textSize,
                height: 0.01
            });
            addTextGeometry.computeBoundingBox();
            addTextGeometry.translate(-(addTextGeometry.boundingBox.max.x - addTextGeometry.boundingBox.min.x)/2, -textSize/2, 0.01);
            const addTextMesh = new THREE.Mesh(addTextGeometry, new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            }));
            addTextMesh.position.copy(addButtonMesh.position);
            addTextMesh.position.z += 0.01;
            addTextMesh.userData = { type: 'addMusicButtonText' };
            sidebarGroup.add(addTextMesh);

            const addClickPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(sidebarWidth - 2 * padding, itemHeight * 0.6),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            addClickPlane.position.copy(addButtonMesh.position);
            addClickPlane.position.z += 0.02;
            addClickPlane.userData = { type: 'addMusicButton' };
            sidebarGroup.add(addClickPlane);
            clickableMeshes.sidebar.push(addClickPlane);

            /*Grabbing music Directories*/
            musicDirectories.forEach((dir, index) => {
                const row = Math.floor(index / columns);
                const col = index % columns;

                const xPos = startX + col * (itemWidth + spacingX);
                const yPos = startY - (row + 1) * (itemHeight + spacingY) - 0.2; // Shift down to accommodate add button

                // Folder background
                const folderBgGeometry = new RoundedBoxGeometry(itemWidth, itemHeight, 0.01, 0.1);
                const folderBgMaterial = new THREE.MeshBasicMaterial({
                    color: index === selectedDirectoryIndex ? 0x4a90e2 : 0x333333,
                    opacity: 0.8,
                    transparent: true
                });
                const folderBg = new THREE.Mesh(folderBgGeometry, folderBgMaterial);
                folderBg.position.set(xPos, yPos, 0);
                folderBg.userData = { type: 'directoryBg', index: index };
                sidebarGroup.add(folderBg);

                // Folder icon
                const iconGeometry = new THREE.BoxGeometry(itemWidth * 0.6, itemHeight * 0.4, 0.01);
                const iconMaterial = new THREE.MeshBasicMaterial({
                    color: index === selectedDirectoryIndex ? 0xffffff : 0x888888,
                    transparent: true,
                    opacity: 0.9
                });
                const iconMesh = new THREE.Mesh(iconGeometry, iconMaterial);
                iconMesh.position.set(xPos, yPos + itemHeight * 0.1, 0.01);
                iconMesh.userData = { type: 'directoryIcon', index: index };
                sidebarGroup.add(iconMesh);

                // Directory name
                let displayName = dir.name;
                if (displayName.length > 8) displayName = displayName.substring(0, 6) + '...';

                const nameGeometry = new TextGeometry(displayName, {
                    font: loadedFont,
                    size: textSize,
                    height: 0.01
                });
                nameGeometry.computeBoundingBox();
                nameGeometry.translate(-(nameGeometry.boundingBox.max.x - nameGeometry.boundingBox.min.x)/2, -textSize/2, 0.01);
                const nameMesh = new THREE.Mesh(nameGeometry, new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9
                }));
                nameMesh.position.set(xPos, yPos - itemHeight * 0.3, 0.02);
                nameMesh.userData = { type: 'directoryText', index: index };
                sidebarGroup.add(nameMesh);

                // Clickable area
                const clickPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(itemWidth, itemHeight),
                    new THREE.MeshBasicMaterial({ visible: false })
                );
                clickPlane.position.set(xPos, yPos, 0.03);
                clickPlane.userData = {
                    type: 'directoryItem',
                    index: index,
                    dirName: dir.name
                };
                sidebarGroup.add(clickPlane);
                clickableMeshes.sidebar.push(clickPlane);
            });
        }

        function updateDirectoryHighlights() {
            sidebarGroup.children.forEach(child => {
                if (child.userData?.type === 'directoryBg') {
                    child.material.color.setHex(
                        child.userData.index === selectedDirectoryIndex ? 0x4a90e2 : 0x333333
                    );
                }
                if (child.userData?.type === 'directoryIcon') {
                    child.material.color.setHex(
                        child.userData.index === selectedDirectoryIndex ? 0xffffff : 0x888888
                    );
                }
            });
        }

        function selectDirectory(index) {
            if (index < 0 || index >= musicDirectories.length) return;

            selectedDirectoryIndex = index;
            const dirName = musicDirectories[index].name;
            currentMusicLibrary = allMusicLibrary[dirName] || [];

            selectedMusicItem = 0;
            musicPageScrollOffset = 0;

            updateTitle(dirName);
            updateDirectoryHighlights();
            createMusicPageElements();

            console.log(`Selected directory: ${dirName} with ${currentMusicLibrary.length} songs`);
        }

// Ensure 'loadedFont' is available (loaded via FontLoader)
// Ensure 'titleGroup' is a THREE.Group() already added to your scene

let currentTitleMesh = null; // Reference to the currently displayed title mesh

function updateTitle(newDirectoryName) 
{
    if (!loadedFont) {
        console.error("Font is not loaded yet. Cannot create text geometry.");
        return;
    }

    // 1. Remove the old title mesh if it exists
    if (currentTitleMesh) {
        titleGroup.remove(currentTitleMesh);
        if (currentTitleMesh.geometry) {
            currentTitleMesh.geometry.dispose();
        }
        if (currentTitleMesh.material) {
            currentTitleMesh.material.dispose();
        }
        currentTitleMesh = null;
    }

    // If newDirectoryName is empty or null, we've cleared the title, so return.
    if (!newDirectoryName) {
        return;
    }

    // 2. Create new TextGeometry for the new title
    const textSize = 0.4; // Adjust size as needed
    const nameGeometry = new TextGeometry(newDirectoryName, {
        font: loadedFont,
        size: textSize,
        height: 0.01, // Minimal depth for on-screen text
        // curveSegments: 12, // Optional: for smoother text
        // bevelEnabled: false // Optional
    });

    // 3. Center the geometry (optional, but good for consistent placement)
    nameGeometry.computeBoundingBox();
    const textWidth = nameGeometry.boundingBox.max.x - nameGeometry.boundingBox.min.x;
    nameGeometry.translate(-textWidth / 2, 0.9, 0.01); // Center horizontally and adjust vertical alignment

    // 4. Create the mesh
    const nameMesh = new THREE.Mesh(nameGeometry, new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.9
    }));

    // 5. Position the new title mesh
    // The positioning (xPos, yPos, itemHeight) depends on your layout.
    // For a main title, you might position it at the top-center of your screen area.
    // Example: Centered horizontally, near the top of where `titleGroup` is meant to display.
    // If titleGroup is at (0,0,0) relative to the screen display area:
    const titleXPosition = 0;
    const titleYPosition = screenHeight * 0.4; // Assuming screenHeight is defined, adjust as needed
    nameMesh.position.set(titleXPosition, titleYPosition, 0.02); // Adjust Z for visibility

    // Your original positioning:
    // nameMesh.position.set(xPos, yPos - itemHeight + 3.5, 0.02);
    // If using this, ensure xPos, yPos, and itemHeight are correctly defined in this scope.

    nameMesh.userData = { type: 'directoryTitle', name: newDirectoryName }; // Optional: for identification

    // 6. Add to the scene and update reference
    titleGroup.add(nameMesh);
    currentTitleMesh = nameMesh;
}



        function createMenuItems() {
            if (!loadedFont) return;

            while (menuGroup.children.length > 0) {
                menuGroup.remove(menuGroup.children[0]);
            }
            clickableMeshes.mainMenu = [];

            const menuItemHeight = screenHeight / (menuItems.length + 1);
            const textSize = menuItemHeight * 0.5;
            const startY = (screenHeight / 2) - menuItemHeight;
            const boxPadding = 0.2;
            const boxDepth = 0.01;

            menuItems.forEach((item, index) => {
                const textGeometry = new TextGeometry(item, {
                    font: loadedFont,
                    size: textSize,
                    height: 0.01
                });
                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
                textGeometry.translate(-textWidth / 2, -textSize/2, 0);

                const textMaterial = new THREE.MeshBasicMaterial({
                    color: index === selectedMenuItem ? 0xffffff : 0x888888
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.y = startY - index * menuItemHeight;
                textMesh.position.x = 0;
                menuGroup.add(textMesh);

                if (item.type === "music")
                {
                /*Creating the box geometry*/
                const boxWidth = textWidth + 2 * boxPadding;
                const boxHeight = textHeight + 2 * boxPadding;
                const boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
                const boxMaterial = new THREE.MeshBasicMaterial
                ({
                    color: 0x333333, // box color
                    transparent: true,
                    opacity: 0.5
                });

                const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                boxMesh.position.copy(textMesh.position);
                boxMesh.position.z -= 0.005;
                menuGroup.add(boxMesh);

                }

                const planeWidth = screenWidth * 0.9;
                const clickPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(planeWidth, menuItemHeight),
                    new THREE.MeshBasicMaterial({ visible: false })
                );
                clickPlane.position.copy(textMesh.position);
                clickPlane.position.z = textMesh.position.z - 0.001;
                clickPlane.userData = { type: 'menuItem', index: index };
                menuGroup.add(clickPlane);
                clickableMeshes.mainMenu.push(clickPlane);
            });

            const selectorSize = textSize * 0.8;
            const selectorGeometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0.0, selectorSize / 2, 0.0,
                selectorSize * 0.8, 0.0, 0.0,
                0.0, -selectorSize / 2, 0.0
            ]);
            selectorGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            const selectorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const selectorMesh = new THREE.Mesh(selectorGeometry, selectorMaterial);
            selectorMesh.name = 'menuSelector';
            selectorMesh.position.set(-(screenWidth / 2) + selectorSize, startY - selectedMenuItem * menuItemHeight, 0);
            menuGroup.add(selectorMesh);
        }

        function createMusicPageElements() {
            if (!loadedFont) return;

            while (musicPageGroup.children.length > 0) {
                musicPageGroup.remove(musicPageGroup.children[0]);
            }
            clickableMeshes.musicPage = [];

            //isMusicPage = true;
            const itemHeight = screenHeight / (ITEMS_PER_SCREEN + 1);
            const textSize = itemHeight * 0.5;
            const startY = (screenHeight / 2) - itemHeight;
            const maxTextWidth = screenWidth * 0.8;

            if (currentMusicLibrary.length === 0) {
                const noMusicTextGeometry = new TextGeometry(
                    selectedDirectoryIndex >= 0 ? "No music in this folder" : "No music found",
                    { font: loadedFont, size: textSize, height: 0.01 }
                );
                noMusicTextGeometry.computeBoundingBox();
                noMusicTextGeometry.translate(-(noMusicTextGeometry.boundingBox.max.x - noMusicTextGeometry.boundingBox.min.x)/2, -textSize/2, 0);
                const noMusicText = new THREE.Mesh(noMusicTextGeometry, new THREE.MeshBasicMaterial({ color: 0xaaaaaa }));
                noMusicText.position.y = startY;
                musicPageGroup.add(noMusicText);

                const addTextGeometry = new TextGeometry("Add Music Folder", {
                    font: loadedFont, size: textSize, height: 0.01
                });
                addTextGeometry.computeBoundingBox();
                addTextGeometry.translate(-(addTextGeometry.boundingBox.max.x - addTextGeometry.boundingBox.min.x)/2, -textSize/2, 0);
                const addMusicText = new THREE.Mesh(addTextGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                addMusicText.position.y = startY - itemHeight;
                musicPageGroup.add(addMusicText);

                const planeWidth = screenWidth * 0.9;
                const clickPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(planeWidth, itemHeight),
                    new THREE.MeshBasicMaterial({ visible: false })
                );
                clickPlane.position.copy(addMusicText.position);
                clickPlane.position.z = addMusicText.position.z - 0.001;
                clickPlane.userData = { type: 'addMusicButton' };
                musicPageGroup.add(clickPlane);
                clickableMeshes.musicPage.push(clickPlane);

            } else {
                const endIndex = Math.min(currentMusicLibrary.length, musicPageScrollOffset + ITEMS_PER_SCREEN);

                for (let i = musicPageScrollOffset; i < endIndex; i++) {
                    const item = currentMusicLibrary[i];
                    const displayIndex = i - musicPageScrollOffset;

                    let displayName = item.name;
                    if (displayName.length > 25) {
                        displayName = displayName.substring(0, 22) + '...';
                    }

                    const textGeometry = new TextGeometry(displayName, {
                        font: loadedFont, size: textSize, height: 0.01
                    });
                    textGeometry.computeBoundingBox();
                    const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                    textGeometry.translate(-(screenWidth/2) + (screenWidth * 0.1), -textSize/2, 0);

                    const isSelected = (i === selectedMusicItem);
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: isSelected ? 0xffffff : 0x888888
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.y = startY - displayIndex * itemHeight;
                    textMesh.userData = { originalColor: isSelected ? 0xffffff : 0x888888 };
                    musicPageGroup.add(textMesh);

                    const planeWidth = screenWidth * 0.9;
                    const clickPlane = new THREE.Mesh(
                        new THREE.PlaneGeometry(planeWidth, itemHeight),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    clickPlane.position.copy(textMesh.position);
                    clickPlane.position.x = 0;
                    clickPlane.position.z = textMesh.position.z - 0.001;
                    clickPlane.userData = { type: 'musicItem', index: i };
                    musicPageGroup.add(clickPlane);
                    clickableMeshes.musicPage.push(clickPlane);
                }

                const selectorSize = textSize * 0.8;
                const selectorGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0.0, selectorSize / 2, 0.0,
                    selectorSize * 0.8, 0.0, 0.0,
                    0.0, -selectorSize / 2, 0.0
                ]);
                selectorGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const selectorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const selectorMesh = new THREE.Mesh(selectorGeometry, selectorMaterial);
                selectorMesh.name = 'musicSelector';
                const selectedDisplayIndex = selectedMusicItem - musicPageScrollOffset;
                selectorMesh.position.set(-(screenWidth / 2) + selectorSize * 0.5, startY - selectedDisplayIndex * itemHeight, 0);
                selectorMesh.visible = (selectedMusicItem >= musicPageScrollOffset && selectedMusicItem < endIndex);
                musicPageGroup.add(selectorMesh);
            }
        }

        function updateMenuSelection(newIndex) {
            if (currentPage !== 'mainMenu' || !menuGroup || menuItems.length === 0) return;

            newIndex = (newIndex + menuItems.length) % menuItems.length;
            selectedMenuItem = newIndex;

            const menuItemHeight = screenHeight / (menuItems.length + 1);
            const startY = (screenHeight / 2) - menuItemHeight;

            menuGroup.children.forEach(child => {
                if (child.geometry?.type === 'TextGeometry') {
                    const textIndex = menuItems.findIndex(item => item === child.geometry.parameters.options.text);
                    if (textIndex !== -1) {
                        child.material.color.setHex(textIndex === selectedMenuItem ? 0xffffff : 0x888888);
                        
                    }
                }
                if (child.name === 'menuSelector') {
                    child.position.y = startY - selectedMenuItem * menuItemHeight;
                }
            });
        }

        function updateMusicSelection(delta) {
            if (currentPage !== 'musicPage' || !musicPageGroup || currentMusicLibrary.length === 0) return;

            let newIndex = selectedMusicItem + delta;
            newIndex = (newIndex + currentMusicLibrary.length) % currentMusicLibrary.length;

            selectedMusicItem = newIndex;

            const selectedDisplayIndex = selectedMusicItem - musicPageScrollOffset;

            if (selectedDisplayIndex < 0) {
                musicPageScrollOffset = selectedMusicItem;
            } else if (selectedDisplayIndex >= ITEMS_PER_SCREEN) {
                musicPageScrollOffset = selectedMusicItem - ITEMS_PER_SCREEN + 1;
            }

            musicPageScrollOffset = Math.max(0, Math.min(musicPageScrollOffset, currentMusicLibrary.length - ITEMS_PER_SCREEN));
            if (currentMusicLibrary.length <= ITEMS_PER_SCREEN) musicPageScrollOffset = 0;

            createMusicPageElements();
        }

        /*SELECTING MENU ITEMS*/
        function selectMenuItem(index) {
            if (currentPage !== 'mainMenu') return;

            const item = menuItems[index];
            console.log(`Main Menu Selected: ${item}`);

            if (item === "Music") 
            {
                currentPage = 'musicPage';
                menuGroup.visible = false;
                musicPageGroup.visible = true;
                sidebarGroup.visible = true;
                selectedMusicItem = 0;
                musicPageScrollOffset = 0;
                createMusicPageElements();
            }
            /*Here we could implement a photo browser 
            i.e. file explorer -> find photos files
            But it just displays the first image if availiable
            */
            else if (item === "Photos")
            {
                if (Object.keys(allImageLibrary).length > 0)
                {
                    const firstDir = Object.Keys(allImageLibrary)[0];
                    if (allImageLibrary[firstDir].length > 0)
                    {
                        displayImage(allImageLibrary[firstDir][0].file);
                    }
                }
            }
        }

        function selectMusicItem(index) {
            if (currentPage !== 'musicPage' || currentMusicLibrary.length === 0 || index < 0 || index >= currentMusicLibrary.length) return;

            const item = currentMusicLibrary[index];
            console.log(`Selected Music: ${item.name}`);

            try {
                if (currentObjectUrl) {
                    URL.revokeObjectURL(currentObjectUrl);
                }

                currentObjectUrl = URL.createObjectURL(item.file);
                audioElement.src = currentObjectUrl;
                audioElement.play()
                    .then(() => console.log(`Playing: ${item.name}`))
                    .catch(error => {
                        console.error("Error playing audio:", error);
                        URL.revokeObjectURL(currentObjectUrl);
                        currentObjectUrl = null;
                        alert(`Error playing ${item.name}: ${error.message}`);
                    });
            } catch (error) {
                console.error("Error setting up audio:", error);
                alert(`Error setting up ${item.name}: ${error.message}`);
                if (currentObjectUrl) {
                    URL.revokeObjectURL(currentObjectUrl);
                    currentObjectUrl = null;
                }
            }
        }

        function goBackToMainMenu() {
            if (currentPage === 'musicPage') {
                currentPage = 'mainMenu';
                menuGroup.visible = true;
                musicPageGroup.visible = false;
                sidebarGroup.visible = false;
            }
        }

        function addMusicFolder() {
            document.getElementById('folder-input').click();
        }
        
        // Image Display Function
        function displayImage(imageFile)
        {
            if (currentImageTexture) 
            {
                currentImageTexture.dispose();
                if (currentImageMesh && imageScreenMesh.children.includes(currentImageMesh))
                {
                    imageScreenMesh.remove(currentImageMesh);
                }
            }

            const reader = new FileReader();
            reader.onload = function(e) 
            {
                const img = new Image();
                img.onload = function()
                {
                    /*Creating the texture from the image*/
                    currentImageTexture = new THREE.Texture(img);
                    currentImageTexture.needsUpdate = true;

                    /*Creating mesh to display the image*/
                    const aspectRatio = img.width / img.height;
                    let width = 6; // Max Width of image screen
                    let height = width / aspectRatio;

                    /*If the image is too tall then scale down*/
                    if (height > screenHeight)
                    {
                        height = screenHeight;
                        width = height * aspectRatio;
                    }

                    const imageGeometry = new THREE.PlaneGeometry(width, height);
                    const imageMaterial = new THREE.MeshBasicMaterial
                    ({
                        map: currentImageTexture,
                        side: THREE.DoubleSide
                    });

                    currentImageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
                    currentImageMesh.position.z = 0.02;
                    imageScreenMesh.add(currentImageMesh);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(imageFile);
        }
      
        // --- Folder Input Handler ---
        document.getElementById('folder-input').addEventListener('change', (event) => {
            const files = event.target.files;
            const newDirectories = new Map();
            const newImageDir = new Map();

            // Process files and extract directory structure
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const pathParts = file.webkitRelativePath.split('/');

                if (pathParts.length > 1) 
                {
                    const dirName = pathParts[0];

                        // Handle Music files
                    if (file.name.match(/\.(mp3|wav|ogg|m4a|flac|aac)$/i) && file.size > 0) 
                    {
                        if (!newDirectories.has(dirName)) 
                        {
                            newDirectories.set(dirName, 
                            {
                                name: dirName,
                                path: dirName,
                                files: []
                            });
                        }
                            newDirectories.get(dirName).files.push
                            ({
                                name: file.name,
                                path: file.webkitRelativePath,
                                file: file,
                                type: 'music'
                            });
                    }
                    else if (file.name.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/i) && file.size > 0)
                    {
                        if (!newImageDir.has(dirName))
                        {
                            newImageDir.set(dirName, 
                                {
                                    name: dirName,
                                    path: dirName,
                                    files: []
                                });
                        }
                        newImageDir.get(dirName).files.push
                        ({
                            name: file.name,
                            path: file.webkitRelativePath,
                            file: file,
                            type: 'image'
                        });
                    }
                }
            }

            // Update state
            const newDirsArray = Array.from(newDirectories.values());
            musicDirectories = [...musicDirectories, ...newDirsArray].sort((a, b) => a.name.localeCompare(b.name));

            allMusicLibrary = {};
            musicDirectories.forEach(dir => {
                allMusicLibrary[dir.name] = dir.files.sort((a, b) => a.name.localeCompare(b.name));
            });

            // Updating image states
            const newImageDirArray = Array.from(newImageDir.values());
            allImageLibrary = {};
            newImageDirArray.forEach(dir => 
            {
                allImageLibrary[dir.name] = dir.files.sort((a,b) => a.name.localeCompare(b.name));
            });


            if (newImageDirArray.length > 0 && newImageDirArray[0].files.length > 0)
            {
                displayImage(newImageDirArray[0].files[0].file);
            }

            // Select first directory if none selected
            if (selectedDirectoryIndex === -1 && musicDirectories.length > 0) {
                selectedDirectoryIndex = 0;
                currentMusicLibrary = allMusicLibrary[musicDirectories[0].name] || [];
            } else if (newDirsArray.length > 0 && selectedDirectoryIndex === -1) {
                // If new directories were added and no directory was previously selected,
                // select the first of the newly added directories.
                const firstNewDirIndex = musicDirectories.findIndex(dir => newDirsArray.some(newDir => newDir.name === dir.name));
                if (firstNewDirIndex !== -1) {
                    selectedDirectoryIndex = firstNewDirIndex;
                    currentMusicLibrary = allMusicLibrary[musicDirectories[selectedDirectoryIndex].name] || [];
                }
            } else if (newDirsArray.length > 0 && selectedDirectoryIndex !== -1) {
                // If new directories are added and a directory is already selected,
                // keep the current selection.
            } else if (musicDirectories.length > 0 && selectedDirectoryIndex >= musicDirectories.length) {
                // Handle case where previously selected index is out of bounds
                selectedDirectoryIndex = musicDirectories.length - 1;
                currentMusicLibrary = allMusicLibrary[musicDirectories[selectedDirectoryIndex].name] || [];
            }
                 /*Updating the music title directory*/
            if (musicDirectories.length > 0)
            {
                let curr_title = "Playlist";
                
                if (selectedDirectoryIndex !== -1 && musicDirectories[selectedDirectoryIndex])
                {
                    curr_title = musicDirectories[selectedDirectoryIndex].name;
                }
                updateTitle(curr_title);
            }
            else 
            {
                updateTitle(null);
            }



            console.log(`Loaded ${musicDirectories.length} directories with ${Object.values(allMusicLibrary).flat().length} songs`);

            // Update UI
            if (loadedFont) {
                createSidebarElements();
                createMusicPageElements();
            }

            event.target.value = null;
        });

        // --- Input Handling ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let clickStartPosition = new THREE.Vector2();
        let currentView = 'screen'; // Add a variable to track the current view

        function onPointerMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            isDragging = false;
            clickStartPosition.set(event.clientX, event.clientY);
        }

        function onPointerUp(event) {
            const dragDistance = clickStartPosition.distanceTo(new THREE.Vector2(event.clientX, event.clientY));

            if (dragDistance < 10) {
                if (currentView === 'screen') {
                    raycaster.setFromCamera(mouse, camera);

                    let intersects;
                    if (currentPage === 'mainMenu' && menuGroup.visible) {
                        intersects = raycaster.intersectObjects(clickableMeshes.mainMenu);
                    } else if (currentPage === 'musicPage' && musicPageGroup.visible) {
                        intersects = raycaster.intersectObjects(clickableMeshes.sidebar);
                        if (intersects.length === 0) {
                            intersects = raycaster.intersectObjects(clickableMeshes.musicPage);
                        }
                    } else {
                        intersects = [];
                    }

                    if (intersects.length > 0) {
                        const clickedObject = intersects[0].object;
                        const userData = clickedObject.userData;

                        if (userData?.type === 'menuItem') {
                            selectMenuItem(userData.index);
                        } else if (userData?.type === 'musicItem') {
                            selectMusicItem(userData.index);
                        } else if (userData?.type === 'addMusicButton') {
                            addMusicFolder();
                        } else if (userData?.type === 'directoryItem') {
                            selectDirectory(userData.index);
                        }
                    }
                }
            }
        }

        function onKeyDown(event) {
            if (currentPage === 'mainMenu') {
                if (event.key === 'ArrowUp') {
                    updateMenuSelection(selectedMenuItem - 1);
                } else if (event.key === 'ArrowDown') {
                    updateMenuSelection(selectedMenuItem + 1);
                } else if (event.key === 'Enter') {
                    selectMenuItem(selectedMenuItem);
                }
            } else if (currentPage === 'musicPage') {
                if (event.key === 'ArrowUp') {
                    updateMusicSelection(-1);
                } else if (event.key === 'ArrowDown') {
                    updateMusicSelection(1);
                } else if (event.key === 'Enter') {
                    selectMusicItem(selectedMusicItem);
                } else if (event.key === 'Escape') {
                    goBackToMainMenu();
                }
            }
        }

        // Update these existing event listeners:
window.addEventListener('pointermove', () => {
    resetIdleTimer();
    onPointerMove(event);
});

window.addEventListener('pointerdown', () => {
    resetIdleTimer();
    onPointerDown(event);
});

window.addEventListener('pointerup', () => {
    resetIdleTimer();
    onPointerUp(event);
});

window.addEventListener('keydown', () => {
    resetIdleTimer();
    onKeyDown(event);
});

// Add these new listeners for mouse and keyboard:
window.addEventListener('mousemove', resetIdleTimer);
window.addEventListener('keypress', resetIdleTimer);
window.addEventListener('click', resetIdleTimer);

// --- Render Loop ---
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

// ====== ADD THE IDLE SPIN CODE RIGHT HERE ======
// --- Idle Spin Variables ---
let lastInteractionTime = Date.now();
const idleSpinDelay = 30000; // 30 seconds
let isIdleSpinning = false;
const idleSpinSpeed = 0;

function resetIdleTimer() {
    lastInteractionTime = Date.now();
    isIdleSpinning = false;
}



// AUDIO VISUALIZER ANIMATIONS
function animates() {
            requestAnimationFrame(animates);
            controls.update();

            // --- Audio Visualizer Update ---
            analyser.getByteFrequencyData(dataArray);

            let average = 0;
            for (let i = 0; i < bufferLength; i++) {
                average += dataArray[i];
            }
            average /= bufferLength;

            // Map the average frequency to the emissive intensity
            const minIntensity = 0.5;
            const maxIntensity = 2.0;
            const intensityRange = maxIntensity - minIntensity;
            const normalizedAverage = average / 255; // Normalize to 0-1
            const glowIntensity = minIntensity + normalizedAverage * intensityRange * 2; // Adjust multiplier for sensitivity

            screenMaterial.emissiveIntensity = Math.max(minIntensity, glowIntensity);
            screenGlowLight.intensity = Math.max(0.5, glowIntensity * 0.8); // Adjust light intensity as well

            renderer.render(scene, camera);
        }

// Modified animate function
const originalAnimate = animate;
animate = function() {
    // Idle check
    const currentTime = Date.now();
    if (currentTime - lastInteractionTime > idleSpinDelay && !isIdleSpinning) {
        isIdleSpinning = true;
    }
    
    // Apply rotation if idle
    if (isIdleSpinning) {
        ipodGroup.rotation.y += idleSpinSpeed;
    }
    
    originalAnimate();
};

// ====== END OF IDLE SPIN CODE ======
// Then continue with your existing code:

// Start animation loop
animate();
animates();


// Ensure AudioContext is resumed on user interaction
       


// Existing event listeners below...

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            } 
        });


    </script>
</body>
</html>